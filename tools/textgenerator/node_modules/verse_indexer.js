var fs = require('fs'),
	path = require('path'),
	base32 = require('base32');


var 
	useBase32 = true,
	removeRegChars = ['\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '[', ']', '{', '}'];
	otherRemoveChars = [
		// roman
		',',';', '!', '-', '–', '―', '—', '~', ':', '"','/', "'s", '’s', "'", '‘', '’', '“', '”', '¿', '<', '>', '&',
		// chinese
		'。', '：', '，', '”', '“', '）', '（', '~', '「', '」'
	],	
	
	//removeChars = ['.',',',';','?','!','-','–','―','—','~',':','"',')','(','[',']','/','\\',"'s",'’s',"'",'‘','’','“','”', '¿', '*', '<','>','&','{','}'],
	
	
	restrictedWords = ['a', 'and', 'about', 'above', 'across', 'after', 'against', 'along', 'among', 'around', 'at', 'before', 'behind', 'below', 'beneath', 'beside', 'between', 'beyond', 'but', 'by', 'despite', 'down', 'during', 'except', 'for', 'from', 'in', 'inside', 'into', 'like', 'near', 'of', 'off', 'on', 'onto', 'id', 'outside', 'over', 'past', 'since', 'the', 'through', 'throughout', 'till', 'to', 'toward', 'under', 'underneath', 'until', 'up', 'upon', 'with', 'within', 'without'],
	regExp = new RegExp('(' + '\\' + removeRegChars.join('|\\') + '|' + otherRemoveChars.join('|') + ')', 'gi');
	
function indexVerse(indexPath, verseCode, text, indexData, lang) {
	
	// remove punctuation
	//for (var i=0, il=removeChars.length; i<il; i++) {
	//	text = text.replace(removeChars[i], '')	
	//}
	text = text.replace(regExp, '');
		
	var words = text.split(' ');
	
	if (lang == 'chs' || lang == 'cht') {
		words = text;
	}
	
	for (var i=0, il=words.length; i<il; i++)  {
		var word = words[i].trim().toLowerCase();
					
		if (word != '' && restrictedWords.indexOf(word) == -1) {
	
			var 
				key = useBase32 ? base32.encode(unescape(encodeURIComponent(word))) : word,
				wordPath = path.join(indexPath, key + '.json'),
				
				// see if we've alreadt started doing this word
				wordData = indexData[key];
				
			
			if (useBase32 && key.indexOf('undefined') > -1) {
				continue;
			}
			
			// create it
			if (!wordData) {
				wordData = {
					"term": word,
					"occurrences": []
				}
				indexData[key] = wordData;	
			}
			
			if (wordData['occurrences'].indexOf(verseCode) == -1) {
				wordData['occurrences'].push(verseCode);				
			}
			
			
		}
	}
	
}


function createIndexFiles(indexPath, indexData) {

	for (var key in indexData) {
		var wordData = indexData[key]	,
			wordPath = path.join(indexPath, key + '.json');
		
		fs.writeFileSync(wordPath, JSON.stringify(wordData));
	}

}

module.exports = {
	createIndexFiles: createIndexFiles,
	indexVerse: indexVerse	
	
}